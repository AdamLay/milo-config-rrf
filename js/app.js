var files = {};
const TYPE_BOARD = 0;
const TYPE_GCODE = 1;

// Implement next and back buttons
$('button[name="next-tab"]').on('click', (e) => {
    e.preventDefault();

    // Check visible form fields when clicking next.
    var valid = true;
    $('input:visible').each((_, e) => {
        if (!e.reportValidity()) {
            valid = false;
        }
    });

    if (!valid) {
        return true;
    }

    var nextTabId = e.target.closest('div.tab-pane').nextElementSibling.id;
    $(`#nav li button[id="${nextTabId}-tab"]`).tab('show');
});

$('button[name="last-tab"]').on('click', (e) => {
    e.preventDefault();
    var lastTabId = e.target.closest('div.tab-pane').previousElementSibling.id;
    $(`#nav li button[id="${lastTabId}-tab"]`).tab('show');
});

$("#nav li button[id='generated-config-tab']").on('show.bs.tab', (e) => {
    var formValues = {};
    $('form').serializeArray().forEach((a) => {
        var val = a.value != "" ? a.value : $(`form input[name="${a.name}"]`).prop('placeholder');
        if (a.name in formValues) {
            if (formValues[a.name].push) {
                formValues[a.name].push(val);
            } else {
                // Create array using existing scalar value
                formValues[a.name] = [formValues[a.name], val];
            }
        } else {
            formValues[a.name] = val;
        }
    });
    generateConfig(formValues);
    generateZip(formValues['mcu_type']);
});

// Process finish button and enable generated config
$('button[name="submit"]').on('click', (e) => {
    if (!$('form')[0].reportValidity()) {
        return true;
    }
    $("#nav li button[id='generated-config-tab']").removeClass('disabled').tab('show');
    return false;
});

$()

// Disable low voltage drivers when 48v selected
$('input[name="motor_voltage"]').on('change',() => {
    var disable = this.value == 48;

    // Disable 24v-only drivers
    $('select[name="driver_type"] option[data-24v-only]').prop('disabled', disable);

    // Select first driver capable of 48v when disabled
    if (disable) {
        $('select[name="driver_type"] option[data-24v-only!=""]').prop('selected', true);
    }
});

// Function stolen from https://codepen.io/gskinner/pen/BVEzox to allow indentation
// of config files within JS code without breaking output.
function dedent(str) {
    str = str.replace(/^\n/, "");
    let match = str.match(/^\s+/);
    return match ? str.replace(new RegExp("^" + match[0], "gm"), "") : str;
}

function generateConfig(f) {
    var ft = f['features'];

    var wifiConfigG = "; WiFi Disabled!";
    var wifiMode = 0;
    var wifiAP = false;
    var netMode = f['network_mode'];

    if (netMode == "wifi_client") {
        wifiConfigG = `M587 S"${f['wifi_ap_name']}" P"${f['wifi_password']}"`;
        wifiMode = 1;
    } else if (netMode == "wifi_ap") {
        wifiConfigG = `M589 S"${f['wifi_ap_name']}" P"${f['wifi_password']}" I${f['wifi_ap_ip']}`;
        wifiMode = 2;
        wifiAP = true;
    }

    var userVarsGeneralG = `
        ; user-vars.g
        ; Holds user-configurable values and overrides for Milo RepRapFirmware configuration.
        ; Generated by the Milo Configurator 
        ; ${(new Date()).toString()}

        ; Set machine name
        global machineName="${f['machine_name']}"

        ; Set features
        set global.featureToolSetter=${ft.includes("toolsetter")}
        set global.featureTouchProbe=${ft.includes("touchprobe")}
        set global.featureVSSC=${ft.includes("vssc")}
        set global.featureCasa=${ft.includes("casa")}
        set global.featureLeds=${ft.includes("leds")}
        set global.featureScreen=${ft.includes("screen")}

        ; Web UI Password
        global dwcPassword="${f['dwc_password']}"

        global parkX={(global.xMax - global.xMin)/2} ; Park approximately in the middle
        global parkY=global.yMax                     ; and at the front for operator ease-of-use.
        global parkZ=global.zMax                     ; Think VERY hard before parking this anywhere else

        ; Confirm with operator on calculated probe moves
        global confirmUnsafeMove = ${f['confirm_unsafe_moves'] == "1"}

        ; Confirm with operator after tool probing
        global confirmToolChange = ${f['confirm_tool_changes'] == "1"}

        ; Safe distance above probed work pieces for travel moves
        global safeDistanceZ     = ${f['safe_z_distance']}

        ; Daemon settings
        ; Required for featureLeds and featureHSSC.
        global daemonEnable=true     ; Run background tasks in daemon.g
        global daemonUpdateRate=500  ; Re-trigger background tasks every 1000ms

        ; WiFi Mode
        set global.wifiAccessPoint = ${wifiAP}
    `;

    var mcrxy = 50;
    var mcrz = 30;

    // Scaling motor current standstill reduction
    if (3500 < f['motor_current']) {
        mcrxy = 7.5;
        mcrz = 5;
    } else if (2500 < f['motor_current']) {
        mcrxy = 15;
        mcrz = 10;
    } else if (1500 < f['motor_current']) {
        mcrxy = 30;
        mcrz = 20;
    }

    var userVarsMotorG = `
        ; Set motor currents
        set global.motorCurrentLimitX=${f['motor_current']}
        set global.motorCurrentLimitY=${f['motor_current']}
        set global.motorCurrentLimitZ=${f['motor_current']}

        ; Set Standstill Currents
        set global.motorHoldCurrentPercentX=${mcrxy}
        set global.motorHoldCurrentPercentY=${mcrxy}
        set global.motorHoldCurrentPercentZ=${mcrz}
    `;

    var runOnceG = `
        ; Enable WiFi adapter in idle mode
        M552 S0

        ; Wait for WiFi adapter to boot.
        ; This can take some time, so the wait
        ; is very conservative.
        G4 S20

        ; Configure WiFi
        ${wifiConfigG}

        ; Wait for the WiFi device to register the config
        G4 S5

        ; Reboot the MCU
        M999
    `;
    files['user-vars.g'] = {
        name: "/sys/user-vars.g",
        input: dedent(userVarsGeneralG + userVarsMotorG)
    };
    files['run-once.g'] = {
        name: "/sys/run-once.g",
        input: dedent(runOnceG),
    }
};

async function generateZip(board) {
    const boards = await loadJSONFile('board-files');

    console.log("Generating Zip file");

    const zip = new fflate.Zip();
    var zipData = [];

    // On each zip output chunk, push it into the zipData array
    // When final chunk, add object URL to download button.
    zip.ondata = (err, chunk, final) => {
        if (err) {
            console.log(err);
            return;
        }
        zipData.push(chunk);
        if(final) {
            const link = $('a#download-bundle')[0];
            link.href = URL.createObjectURL(new Blob(zipData, { type: 'application/zip' }));
            link.download = "milo-rrf-config.zip";
        }
    };

    // Push all necessary files into zip, do not compress as they're already downloaded.
    for([src, file] of Object.entries(files)) {
        if(file['type'] == TYPE_BOARD) {
            if(src != board) {
                continue;
            }
        }
        const zipFile = new fflate.ZipPassThrough(file['name'].slice(1));
        zip.add(zipFile);
        zipFile.push(file['input'], true);
    }

    zip.end();
}

$(async function () {
    try {

        const config = await loadJSONFile('config');

        // Neither of these are actually lists.
        const fileList  = Object.entries(await loadJSONFile('gcode-files'));
        const boardList = Object.entries(await loadJSONFile('board-files'));

        var fileRoot = `${config['downloadRoot']}/${config['downloadBranch']}`;

        // Pre-download the files as page is loading!
        const requests = [];
        for ([src, dst] of fileList) {
            var request = fetch(fileRoot + src);
            requests.push(request);
            files[src] = { name: dst, input: "", type: TYPE_GCODE, promise: request };
        }

        for ([boardName, info] of boardList) {
            var request = fetch(fileRoot + info['src']);
            requests.push(request);
            files[boardName] = { name: info['dst'], input: "", type: TYPE_BOARD, promise: request };
        }

        const errors = (await Promise.all(requests)).filter((response) => !response.ok);

        if (errors.length > 0) {
            throw Error("Unable to download required files, please try again.");
        }

        for ([src, info] of Object.entries(files)) {
            info['input'] = await (await info['promise']).text();
            delete info['promise'];
            files[src] = info;
        }

    } catch (error) {
        console.log(error);
        $('#alert').text(`ERROR: ${error.toString()}`).show();
    }
});

async function loadJSONFile(fileName) {
    const response = await fetch(`./${fileName}.json`);
    if (!response.ok) {
        return {};
    }
    return response.json();
}